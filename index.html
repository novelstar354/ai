<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<link rel="icon" href="https://store-images.s-microsoft.com/image/apps.14785.14423064005243201.42399137-369b-40bb-b5be-ac2f079c41bf.b1d6d110-9d93-441f-ac20-2e04fd7dfe3c" sizes="16×16" type="image/png" />   
<title>ネガポジ無双</title>
<style>
  :root{--bg:#0b1220;--card:#0f1724;--muted:#9aa7b2;--accent:#ff6b6b}
  html,body{height:100%;margin:0;font-family:Inter, "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;background:linear-gradient(180deg,#071022,#071a2b);color:#e6eef6}
  .wrap{max-width:980px;margin:28px auto;padding:20px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border-radius:12px;padding:16px;box-shadow:0 8px 30px rgba(2,8,23,0.6)}
  h1{margin:0 0 8px;font-size:20px}
  p.lead{margin:0 0 12px;color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px;margin-top:12px}
  textarea{width:100%;min-height:220px;padding:12px;border-radius:8px;border:1px solid #1d2b3a;background:#081022;color:#eaf4ff;resize:vertical}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
  button{border:0;padding:10px 12px;border-radius:8px;cursor:pointer;font-weight:600;background:#0b1220;color:#eaf4ff}
  button.primary{background:linear-gradient(90deg,var(--accent),#ff8b8b);color:#071022}
  label{font-size:13px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  .mini{font-size:13px;padding:6px 8px;border-radius:6px;background:#0b1220}
  .output{white-space:pre-wrap;padding:12px;border-radius:8px;background:#071826;border:1px solid #12303e;min-height:220px}
  .meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px;color:var(--muted);font-size:13px}
  select{background:#071826;color:#eaf4ff;border:1px solid #274349;padding:6px;border-radius:6px}
  .footer{margin-top:12px;color:var(--muted);font-size:12px}
  .badge{background:#09212a;padding:4px 8px;border-radius:999px;font-size:12px}
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>ネガポジ無双</h1>
      <p class="lead">入力したテキスト中のポジティブ語をネガティブな語に置き換えます。日本語 / English に対応。強さを上げるとより厳しい語に変換します。</p>

      <div class="row" style="gap:10px;">
        <label>言語:</label>
        <select id="lang">
          <option value="auto">自動検出 (auto)</option>
          <option value="ja">日本語 (ja)</option>
          <option value="en">English (en)</option>
        </select>

        <label>強さ:</label>
        <select id="intensity" class="mini">
          <option value="0">弱め</option>
          <option value="1" selected>普通</option>
          <option value="2">強め</option>
        </select>

        <label style="margin-left:auto">大文字保持</label>
        <input type="checkbox" id="preserveCase" checked style="transform:scale(1.1)"/>
      </div>

      <div class="grid">
        <div>
          <label>入力テキスト（ここにポジティブな言葉や文章を貼ってください）</label>
          <textarea id="input" placeholder="例：今日は素晴らしい日だ。君の仕事はとても素敵だ。"></textarea>
          <div class="controls">
            <button id="convertBtn" class="primary">変換する (Negatify)</button>
            <button id="clearBtn" class="mini">クリア</button>
            <button id="swapBtn" class="mini">出力→入力</button>
            <button id="downloadBtn" class="mini">結果をダウンロード</button>
          </div>
        </div>

        <div>
          <label>出力（ネガティブ化されたテキスト）</label>
          <div id="output" class="output" aria-live="polite"></div>
          <div class="meta">
            <div class="badge" id="seedInfo">seed: -</div>
            <div>
              <button id="copyBtn" class="mini">コピー</button>
              <button id="explainBtn" class="mini">変換ログ表示</button>
            </div>
          </div>
        </div>
      </div>

      <div style="margin-top:12px">
        <strong>ヒント:</strong> 辞書に載っていない言葉は自動で否定形にします（日本語:「〜ではない」等 / English: prefix "not "）。悪意のある用途での利用はお控えください。
      </div>

      <div class="footer">Made with care • simple rule-based "AI" — edit the built-in dictionaries in the source to change behavior.</div>
    </div>
  </div>

<script>
/*
  ポジティブ→ネガティブ 変換ロジック（疑似AI）
  - 辞書ベース（複数候補）＋ランダム選択（seeded）
  - 未登録語は否定形にフォールバック
  - 日本語は長い語順で置換（最大一致）することで部分置換を抑える
*/

const POS_NEG = {
  // 日本語マップ: キー(ポジ) -> 候補配列(ネガ)
  ja: {
    '素晴らしい':['最悪だ','最低だ','ひどい'],
    '素敵':['最低','ひどい','最悪'],
    '大好き':['大嫌い','嫌いになった'],
    '好き':['嫌い','苦手'],
    '幸せ':['不幸','悲惨だ'],
    '嬉しい':['腹が立つ','不愉快だ'],
    '楽しい':['つまらない','苦痛だ'],
    '最高':['最悪','最凶'],
    '良い':['悪い','ひどい'],
    '良かった':['悪かった','ダメだった'],
    '前向き':['後ろ向き','悲観的'],
    '成功':['失敗','破綻'],
    '成功した':['失敗した','やらかした'],
    '平和':['混乱','争い'],
    '優しい':['冷酷','無情'],
    '誠実':['ずるい','不誠実'],
    'かっこいい':['ダサい','みっともない'],
    '綺麗':['醜い','汚い'],
    '美しい':['醜悪だ','みにくい'],
    '頼もしい':['頼りない','無駄だ'],
    '安定':['不安定','崩壊'],
    '希望':['絶望','失望'],
    '可能':['不可能','無理'],
    '感謝':['軽蔑','無視'],
    '信頼':['不信','裏切り']
    '理解できぬ':['だまれよ','理解しろや']
    'スターコーポレーションは神':['そうだよ','知ってた。']
  },

  // English map
  en: {
    'great':['terrible','awful','horrible'],
    'good':['bad','poor','lousy'],
    'love':['hate','detest','despise'],
    'happy':['miserable','sad','dejected'],
    'beautiful':['ugly','hideous'],
    'nice':['nasty','cruel'],
    'wonderful':['dreadful','horrendous'],
    'fun':['boring','agonizing'],
    'successful':['failed','unsuccessful'],
    'confident':['insecure','timid'],
    'kind':['cruel','cold'],
    'trustworthy':['unreliable','deceitful'],
    'peaceful':['chaotic','violent'],
    'hope':['despair','hopelessness'],
    'possible':['impossible','unachievable']
  }
};

// simple seeded RNG (xorshift32)
function xorshift32(seed){
  let x = seed >>> 0 || 2463534242;
  return function(){
    x ^= x << 13; x = x >>> 0;
    x ^= x >>> 17; x = x >>> 0;
    x ^= x << 5;  x = x >>> 0;
    return (x >>> 0) / 4294967295;
  }
}

function detectLang(text){
  // simple heuristic: contains CJK => ja; contains many ascii letters => en
  const cjk = /[\u3040-\u30ff\u4e00-\u9fff]/;
  const asciiLetters = /[A-Za-z]/;
  if (cjk.test(text) && !/^[A-Za-z0-9\s\.,!?'"()]+$/.test(text)) return 'ja';
  if (asciiLetters.test(text) && !cjk.test(text)) return 'en';
  return 'ja'; // default
}

// longest-first replacement for Japanese
function buildReplaceList(map){
  // return keys sorted by length desc for greedy replacement
  return Object.keys(map).sort((a,b)=>b.length - a.length);
}

// apply replacement with intensity
function pickCandidate(candidates, intensity, rng){
  // intensity: 0 (mild) 1(normal) 2(strong)
  // stronger intensity -> pick later (stronger) candidates
  const n = candidates.length;
  if (n===1) return candidates[0];
  const indexBase = Math.floor(rng() * n);
  // bias towards end if intensity high
  let bias = Math.round((intensity/2) * (n-1));
  let idx = Math.min(n-1, Math.max(0, indexBase + bias));
  return candidates[idx];
}

function preserveCaseTransform(orig, replaced){
  // for English: keep capitalization pattern
  if (!/[A-Za-z]/.test(orig)) return replaced;
  // all caps?
  if (orig === orig.toUpperCase()) return replaced.toUpperCase();
  // capitalized?
  if (orig[0] === orig[0].toUpperCase()) return replaced[0].toUpperCase() + replaced.slice(1);
  return replaced;
}

function negateFallback(token, lang){
  if (lang === 'ja'){
    // for Japanese, try simple patterns
    // if ends with い-adj (rough): transform い -> くない (approx)
    if (/い$/.test(token) && token.length>1){
      return token.replace(/い$/, 'くない');
    }
    // if ends with だ / です / ます -> replace with ではない / ではありません
    if (/だ$/.test(token)) return token.replace(/だ$/, 'ではない');
    if (/です$/.test(token)) return token.replace(/です$/, 'ではありません');
    // otherwise: append "ではない" (more natural: "〜ではない")
    return token + 'ではない';
  } else {
    // English: prefix "not " unless starts with a verb? simple
    // If token begins with lowercase letter, use 'not ' + token
    // If token contains spaces (phrase), prefix not before phrase
    if (/\s/.test(token)) return 'not ' + token;
    return 'not ' + token;
  }
}

// main transform
function transform(text, options){
  const {lang, intensity, seed, preserveCase} = options;
  const rng = xorshift32(seed || (Math.floor(Math.random()*0xffffffff)));
  document.getElementById('seedInfo').textContent = 'seed: ' + (seed || 'auto-' + Math.floor(rng()*1e9));

  if (lang === 'ja'){
    // greedy replacement by longest keys
    const map = POS_NEG.ja;
    const keys = buildReplaceList(map);
    let log = [];
    // To avoid overlapping replacements, we process with regex that matches keys
    // We'll walk text and replace occurrences one by one.
    // Use global regex built from keys (escape)
    const esc = s => s.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&');
    const pattern = new RegExp(keys.map(esc).join('|'), 'g');
    const replaced = text.replace(pattern, (match)=>{
      const candidates = map[match];
      const chosen = pickCandidate(candidates, intensity, rng);
      log.push({from:match,to:chosen});
      return chosen;
    });

    // if nothing matched, try token-level fallback: split by punctuation/space and replace tokens
    if (log.length===0){
      // naive tokenization by separators
      let changed = false;
      const out = replaced.split(/(\s+|[、。．，！？\?\!])/).map(token=>{
        if (!token || /\s|[、。．，！？\?\!]/.test(token)) return token;
        // try lowercase map keys equal
        if (map[token]){
          const chosen = pickCandidate(map[token], intensity, rng);
          log.push({from:token,to:chosen});
          changed = true;
          return chosen;
        }
        // fallback: negate
        const neg = negateFallback(token,'ja');
        log.push({from:token,to:neg});
        changed = true;
        return neg;
      }).join('');
      return {text: out, log};
    }

    return {text: replaced, log};
  } else {
    // English: word-boundary replacement
    const map = POS_NEG.en;
    const keys = Object.keys(map).sort((a,b)=>b.length - a.length);
    const esc = s => s.replace(/[-/\\^$*+?.()|[\]{}]/g,'\\$&');
    const pattern = new RegExp('\\b(' + keys.map(esc).join('|') + ')\\b', 'gi');
    let log = [];
    const out = text.replace(pattern, (match)=>{
      const lower = match.toLowerCase();
      const candidates = map[lower];
      const chosen = pickCandidate(candidates, intensity, rng);
      const final = preserveCase ? preserveCaseTransform(match, chosen) : chosen;
      log.push({from:match,to:final});
      return final;
    });

    // if nothing replaced: fallback to prefix "not "
    if (log.length===0){
      // try simple phrase fallback per sentence
      const out2 = text.split(/([.!?]\s|$)/).map(part=>{
        if (!part.trim()) return part;
        // prefix "Not " to lead word
        const m = part.match(/^(\s*)([A-Za-z'-]+)/);
        if (m){
          const word = m[2];
          const neg = 'not ' + word.toLowerCase();
          log.push({from:word,to:neg});
          return part.replace(word, preserveCase ? preserveCaseTransform(word, neg) : neg);
        }
        return part;
      }).join('');
      return {text: out2, log};
    }

    return {text: out, log};
  }
}

// UI wiring
const inputEl = document.getElementById('input');
const outputEl = document.getElementById('output');
const convertBtn = document.getElementById('convertBtn');
const clearBtn = document.getElementById('clearBtn');
const swapBtn = document.getElementById('swapBtn');
const downloadBtn = document.getElementById('downloadBtn');
const copyBtn = document.getElementById('copyBtn');
const explainBtn = document.getElementById('explainBtn');
const langSelect = document.getElementById('lang');
const intensityEl = document.getElementById('intensity');
const preserveCaseEl = document.getElementById('preserveCase');

let lastLog = [];

convertBtn.addEventListener('click', ()=>{
  const raw = inputEl.value.trim();
  if (!raw){ outputEl.textContent = ''; return; }
  // language detection / selection
  let lang = langSelect.value;
  if (lang === 'auto') lang = detectLang(raw);
  const intensity = Number(intensityEl.value);
  // seed: use timestamp for variability but expose seed for reproducibility
  const seed = Math.floor(Math.random()*0xffffffff);
  const preserveCase = preserveCaseEl.checked;

  const result = transform(raw, {lang, intensity, seed, preserveCase});
  outputEl.textContent = result.text;
  lastLog = result.log || [];
  document.getElementById('seedInfo').textContent = 'seed: ' + seed;
});

clearBtn.addEventListener('click', ()=>{ inputEl.value=''; outputEl.textContent=''; lastLog=[]; document.getElementById('seedInfo').textContent='seed: -'; });

swapBtn.addEventListener('click', ()=>{
  const out = outputEl.textContent || '';
  inputEl.value = out;
  outputEl.textContent = '';
});

copyBtn.addEventListener('click', ()=>{
  const t = outputEl.textContent || '';
  if (!t) return;
  navigator.clipboard?.writeText(t).then(()=>{ copyBtn.textContent = 'コピーしました'; setTimeout(()=>copyBtn.textContent='コピー',1200); }).catch(()=>alert('コピーできませんでした'));
});

downloadBtn.addEventListener('click', ()=>{
  const t = outputEl.textContent || '';
  if (!t){ alert('出力が空です'); return; }
  const blob = new Blob([t], {type:'text/plain;charset=utf-8'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'negatified.txt';
  a.click();
  URL.revokeObjectURL(a.href);
});

explainBtn.addEventListener('click', ()=>{
  if (!lastLog.length){ alert('変換ログはありません（辞書にマッチしなかったか、まだ変換していません）'); return; }
  // show a modal-like alert with log
  const lines = lastLog.map((l,i)=>`${i+1}. "${l.from}" → "${l.to}"`).join('\\n');
  alert('変換ログ:\\n' + lines);
});

// Optional: keyboard shortcut Ctrl/Cmd+Enter to convert
document.addEventListener('keydown', (e)=>{
  if ((e.ctrlKey || e.metaKey) && e.key==='Enter'){ convertBtn.click(); }
});

</script>
</body>
</html>
